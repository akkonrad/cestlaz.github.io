<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AOC on C&#39;est la Z</title>
    <link>https://cestlaz.github.io/categories/aoc/</link>
    <description>C&#39;est la Z (AOC)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 02 Dec 2020 12:27:27 -0400</lastBuildDate>
    
    <atom:link href="https://cestlaz.github.io/categories/aoc/rss.xml" rel="self" type="application/rss" />
    
    
    <item>
      <title>A Teacher Looks at Advent of Code 2020 - Day 2</title>
      <link>https://cestlaz.github.io/post/advent-2020-day02/</link>
      <pubDate>Wed, 02 Dec 2020 12:27:27 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-day02/</guid>
      <description>&lt;p&gt;
Day two introduced some staples of staples of not only Advent of Code but
also of programming problems in general. The first is input
parsing. For this problem you get lines of input like this:
&lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
1-3 a: abcde
1-3 b: cdefg
2-9 c: cccccccc
&lt;/pre&gt;
&lt;p&gt;
or in general
&lt;/p&gt;
&lt;p&gt;
&lt;strong&gt;number_1&lt;/strong&gt;-&lt;strong&gt;number_2&lt;/strong&gt; &lt;strong&gt;Letter&lt;/strong&gt;: &lt;strong&gt;String&lt;/strong&gt; 
&lt;/p&gt;
&lt;p&gt;
There are a few ways to handle this. One is to brute force it. In
Python maybe something like: 
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;sample_line&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;4-15 f: abcdefg&amp;#34;&lt;/span&gt;
sample_list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sample_line&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split()
numbers&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sample_list[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
letter&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sample_list[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
string&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sample_list[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]

number_list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; numbers&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;)
num1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(number_list[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;])
num2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(number_list[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])

letter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; letter[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]

&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(num1, num2, letter, string)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
or more concisely: 
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;sample_line&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;4-15 f: abcdefg&amp;#34;&lt;/span&gt;

(numbers,letter,string) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sample_line&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split()

(num1,num2) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [int(x) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; numbers&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;)]

letter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; letter[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]

&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(num1, num2, letter, string)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
If you&amp;#39;re working in a language like C, tools like &lt;code&gt;scanf&lt;/code&gt; can make
things easier. I generally turn to &lt;a href=&#34;https://blog.usejournal.com/regular-expressions-a-complete-beginners-tutorial-c7327b9fd8eb&#34;&gt;Regular Expressions&lt;/a&gt; and if you&amp;#39;re
doing some AOC with your classes this is a great time to introduce
regex. Basically, you set up a pattern with special symbols to
represent things like sequences of digits and then the regex matcher
does the hard work.
&lt;/p&gt;
&lt;p&gt;
Here&amp;#39;s the code to 
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;parser_expression&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;(\d+)-(\d+) ([a-z]): ([a-z]*)&amp;#34;&lt;/span&gt;
data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; line &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;../data/day02.dat&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;readlines():
    x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; re&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;search(parser_expression,line)
    (mini,maxi,letter,password) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;groups()
    mini &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(mini)
    maxi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(maxi)
    data&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append([mini,maxi,letter,password])&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
The &lt;code&gt;parser_expression&lt;/code&gt; in line 1 is the regular expression. Each
section in parentheses is a &amp;#34;group&amp;#34; or a pattern that will be
extracted. The &lt;strong&gt;\d&lt;/strong&gt; for instance means a digit and the &lt;strong&gt;+&lt;/strong&gt; adger it
means 1 or more digits so basically that will match any positive
integer. The &lt;strong&gt;[a-z]&lt;/strong&gt; matches a single character and the *after the
final character match means zero or more of them. Once you know
regular expressions, parsing lines like this becomes very easy. The
only thing that made the above code messy at all was that I wanted to
convert the two numbers into integers rather than leave them as
strings. 
&lt;/p&gt;
&lt;p&gt;
There are a couple of things worth thinking about here. First is know
your libraries. If you know regex the parsing is basically all
done. If not, you have a bit of work. On the other hand, you&amp;#39;re
probably not going to ever have to parse input exactly like this again
so it doesn&amp;#39;t make sense writing a super robust set of  parsing
functions tied in with this data specification. That&amp;#39;s the second
thing. Learning what to leave as building blocks and what to write
into libraries of your own. It&amp;#39;s most definitely worth writing a set
of routines that can be reused. Maybe something to parse dates in a
standard format would be an example. On the other hand, it&amp;#39;s also
worth knowing when you probably won&amp;#39;t be able to reuse things or when
generalizing to a library or set of functions you have to spend too
much time on a hundred options to make in general purpose.
&lt;/p&gt;
&lt;p&gt;
Now, part 1 of the problem itself is nice because there are a lot of
ways to do it. You could loop through the password and count the
number of times a letter occurs: 
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; letter &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; password:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; letter &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; what_im_looking_for:
        count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
or with a list comprehension &lt;code&gt;count = [x for x in password if x ==
waht_im_looking_for ]&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
You could be more general and build a hash table of counts and then
pull what you want: 
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;frequencies&lt;/span&gt;(word):
    d&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;{}
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; letter &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; word:
        d&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;setdefault(letter,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
        d[letter]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;d[letter]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; d&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
This is admittedly overkill for the problem but one might need this
for part 2. I coded my original solution in Clojure and Clojure has a
function that does this in one shot: &lt;code&gt;frequencies&lt;/code&gt; so I just used that
and pulled the letter I needed.
&lt;/p&gt;
&lt;p&gt;
Once you have the count, it&amp;#39;s simple enough to see if it&amp;#39;s in the
range.
&lt;/p&gt;
&lt;p&gt;
Part 2 should have been easy but for me it was a lesson in
reading. You had to pull characters from the password at two specific
indices and see if one or the other, but not both were the letter in
question. Basically an xor. The first mistake one could make has to do
with the indexing and the second in using a regular or which students
will be more familiar with. 
&lt;/p&gt;
&lt;p&gt;
My mistake is that I misread the question as requiring that you have
one instance of the letter within the &lt;strong&gt;range&lt;/strong&gt; from the low index to
the high index not one instance at either of those two points Needless
to say, lots of wasted time and feeling silly. 
&lt;/p&gt;
&lt;p&gt;
So that&amp;#39;s day 2. The question is very approachable for APCS-A  and I&amp;#39;d
say even CS0 students. The interesting part to teach would be dealing
with the input, regular expressions, and how much to generalize into
utility functions when writing code over time.
&lt;/p&gt;
&lt;p&gt;
Hope to have time to solve and write up more of these but getting to
crunch time in the semester.
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2020</title>
      <link>https://cestlaz.github.io/post/advent-2020-leadin/</link>
      <pubDate>Mon, 30 Nov 2020 14:21:17 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-leadin/</guid>
      <description>&lt;p&gt;
Tomorrow, or more practically, tonight at Midnight,  &lt;a href=&#34;https://twitter.com/ericwastl&#34;&gt;Eric Wastl&lt;/a&gt; will
once again launch the &lt;a href=&#34;https://adventofcode.com&#34;&gt;Advent of Code&lt;/a&gt;. As I&amp;#39;ve written before, it&amp;#39;s a
month long event where each day a new programming problem is
released. The problems range in difficulty and complexity. Some are
very approachable to beginners and some are crazy challenging. I&amp;#39;ve
written a bunch about AOC in past years:
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://cestlaz.github.io/post/solve-a-to-solve-b/&#34;&gt;Solve A to Solve B&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://cestlaz.github.io/post/aoc-data-structures-hidden-complexity/&#34;&gt;Data structures and Hidden Complexity&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://cestlaz.github.io/posts/advent-2017-4-6/&#34;&gt;Tools can shape- how we think&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day1/&#34;&gt;2019 day 1&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day2/&#34;&gt;2019 day 2&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day3/&#34;&gt;2019 day 3&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day4/&#34;&gt;2019 day 4&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day8/&#34;&gt;2019 day 8&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day8-part2/&#34;&gt;2019 day 8 addendum&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
and a few more not listed.
&lt;/p&gt;
&lt;p&gt;
If you haven&amp;#39;t heard of AOC, at the stroke of midnight (Eastern), a
new problem is released. From there you can read the problem, get the
input and figure out a solution, usually by writing a program. You
then type in your answer and if it&amp;#39;s correct you get part 2 - usually
a creative spin on part one. Usually you&amp;#39;ll write a program to solve
the problems but sometimes you&amp;#39;ll write code just to explore and come
up with an answer. 
&lt;/p&gt;
&lt;p&gt;
Even though there&amp;#39;s a leader board and people can set up their own
private leader boards, I describe AOC as an event not as a
competition. I&amp;#39;ve had former students up near the top but a getting
there requires a lot more than just problem solving. First, you have
to be up when the problem is released, then you have to shortcut scan
what the question is asking. Having a library of pre-written utility
routines is a big help as is using a language that has a lot of
interactive scripty functionality like Python. It also assumes that
even if you do all that is needed, that life doesn&amp;#39;t get in the
way. This means that to get to the top of the leader board, like in
most competitions you have to train and prepare to do just that and
training for that doesn&amp;#39;t really translate to the rest of life&amp;#39;s
challenges.
&lt;/p&gt;
&lt;p&gt;
Solving the problems, though, can translate to other challenges you
might face so I look at AOC as an opportunity to explore some
interesting problems. 
&lt;/p&gt;
&lt;p&gt;
I&amp;#39;ve never finished all of them and that&amp;#39;s okay. Here&amp;#39;s my star count
for each of the years. You get one star for each part of each question
so that&amp;#39;s 50 total.
&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Year:&lt;/strong&gt;&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;2015&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;2016&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;2017&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;2018&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;2019&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Stars:&lt;/strong&gt;&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;26&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;40&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;11&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;23&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;31&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
I&amp;#39;ve never gotten more than 40. I typically wake up and read the
question and see if I can solve it either then or over the course of
the day. Sometimes I&amp;#39;ll come back to a problem but usually not. Last
year, many problems were based on earlier ones. I had an issue in one
of those earlier solutions so never completed the later ones. 
&lt;/p&gt;
&lt;p&gt;
Maybe I&amp;#39;ll go back and finish more, maybe I won&amp;#39;t.
&lt;/p&gt;
&lt;p&gt;
None of this matters. 
&lt;/p&gt;
&lt;p&gt;
I had fun, learned a lot and as an added bonus, each problem gives me
an opportunity to reflect on how I might teach it or teach concepts
related to it.
&lt;/p&gt;
&lt;p&gt;
It all starts in a few hours so if you&amp;#39;re already planning on
participating, have a blast. If you haven&amp;#39;t, check it out.
&lt;/p&gt;
&lt;p&gt;
Advent of code can be found here: &lt;a href=&#34;https://adventofcode.com&#34;&gt;https://adventofcode.com&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
And, the AOC subreddit, which is great for problem discussions can be
found here: &lt;a href=&#34;https://www.reddit.com/r/adventofcode/&#34;&gt;https://www.reddit.com/r/adventofcode/&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
Enjoy. 
&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>