<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AOC on C&#39;est la Z</title>
    <link>https://cestlaz.github.io/tags/aoc/</link>
    <description>C&#39;est la Z (AOC)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 05 Dec 2020 11:18:59 -0400</lastBuildDate>
    
    <atom:link href="https://cestlaz.github.io/tags/aoc/rss.xml" rel="self" type="application/rss" />
    
    
    <item>
      <title>A teacher looks at Advent of Code 2020 - Day 5</title>
      <link>https://cestlaz.github.io/post/advent-2020-day05/</link>
      <pubDate>Sat, 05 Dec 2020 11:18:59 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-day05/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;https://adventofcode.com/2020/day/5&#34;&gt;Day five&amp;#39;s problem&lt;/a&gt; is a nice one for an early CS class. It can be very
much brute forced but it also touches on some nice concepts and can be
solved pretty elegantly. I&amp;#39;ve embedded a walk through in Clojure at
the end but a Python solution would be pretty similar.  
&lt;/p&gt;
&lt;p&gt;
Read the problem over if you haven&amp;#39;t. At it&amp;#39;s core you are taking a boarding
pass representing a coded airplane seat number and you&amp;#39;re converting
it to a known seat (row and column). The encoding scheme uses &lt;a href=&#34;https://en.wikipedia.org/wiki/Binary_space_partitioning&#34;&gt;binary
space partitioning&lt;/a&gt;. The &lt;a href=&#34;https://adventofcode.com/2020/day/5&#34;&gt;question statement&lt;/a&gt; goes over the details.
&lt;/p&gt;
&lt;p&gt;
One of the first things to notice is that you should separate the pass
into two parts - the row, which consists of the first seven characters
each one being an &lt;strong&gt;F&lt;/strong&gt; or a &lt;strong&gt;B&lt;/strong&gt; and the last three which are the
columns and they are marked with either a &lt;strong&gt;R&lt;/strong&gt; or an &lt;strong&gt;L&lt;/strong&gt;.
&lt;/p&gt;
&lt;p&gt;
So, the sample pass &lt;strong&gt;FBFBBFFRLR&lt;/strong&gt; separates into &lt;strong&gt;FBFBBFF&lt;/strong&gt; for the row
and &lt;strong&gt;RLR&lt;/strong&gt; for the clumn.
&lt;/p&gt;
&lt;p&gt;
There are 128 rows numbered 0 through 127 so you start with 127 (the
back of the plane) and then depending on if the next character is an
&lt;strong&gt;F&lt;/strong&gt; or a &lt;strong&gt;B&lt;/strong&gt; you either subtract out half the range size or you
don&amp;#39;t. If the character is an &lt;strong&gt;B&lt;/strong&gt; you don&amp;#39;t since you&amp;#39;re at the back
of the section and the back rows are higher. If it&amp;#39;s a &lt;strong&gt;F&lt;/strong&gt; you do
since you&amp;#39;re at the front and front rows have lower numbers.
&lt;/p&gt;
&lt;p&gt;
So, the first &lt;strong&gt;F&lt;/strong&gt; says you&amp;#39;re at the front so you subtract &lt;strong&gt;half&lt;/strong&gt; the
range and now you&amp;#39;re looking at 0-63. The next character is a &lt;strong&gt;B&lt;/strong&gt; so
you don&amp;#39;t subtract anything but you&amp;#39;ll be next looking at 32 through
63 etc. The question has a full walk through.
&lt;/p&gt;
&lt;p&gt;
Looking at the  row string, you have &lt;strong&gt;FBFBBFF&lt;/strong&gt;. If we substitute the
amount we subtract for the letters we get &lt;code&gt;64 0 16 0 0 2 1&lt;/code&gt; or the
place values of a binary number &lt;strong&gt;in reverse&lt;/strong&gt;. 
&lt;/p&gt;
&lt;p&gt;
In my solution, I reversed the string and then converted each &lt;strong&gt;F&lt;/strong&gt; or &lt;strong&gt;B&lt;/strong&gt;
into a number. A &lt;strong&gt;B&lt;/strong&gt; became a 0 and an &lt;strong&gt;F&lt;/strong&gt; became 2^i where &lt;strong&gt;i&lt;/strong&gt; is the
location (index) in the string. For the sample string, once reversed
to &lt;strong&gt;FFBBFBF&lt;/strong&gt; it gives &lt;code&gt;1 2 0 0 16 0 64&lt;/code&gt;. If we sum those up and
subtract from 127 we get our row number.
&lt;/p&gt;
&lt;p&gt;
We basically can do the same thing for the column but there you
subtract from 7.
&lt;/p&gt;
&lt;p&gt;
Part 1 of the question asks you to map the row and column to a final
number by calcualing &lt;code&gt;row*8+col&lt;/code&gt; and then find the highest seat number
from a give list of boarding passes.
&lt;/p&gt;
&lt;p&gt;
Part 2 requires you look through all the boarding passes to determine
your actual seat - the one seat missing from the data set.
&lt;/p&gt;
&lt;p&gt;
Lots of good stuff for a class in this question.
&lt;/p&gt;
&lt;p&gt;
You&amp;#39;ve got the basic data parsing as usual but I love that this can be
brute forced but by noticing the base 2 nature of the data you can
write up a number of different elegant solutions. 
&lt;/p&gt;
&lt;p&gt;
Here&amp;#39;s a complete solution coded up in Clojure. You can also check all
my Advent of Code solutions up on GitHub
&lt;a href=&#34;https://github.com/zamansky/advent2020&#34;&gt;https://github.com/zamansky/advent2020&lt;/a&gt;. 
&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/lq5AdWkzyjg&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>A Teacher Looks at Advent of Code 2020 - Day 4</title>
      <link>https://cestlaz.github.io/post/advent-2020-day04/</link>
      <pubDate>Fri, 04 Dec 2020 17:31:06 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-day04/</guid>
      <description>&lt;p&gt;
One of the nice things about Advent of Code is that it gets me to
explore language features I haven&amp;#39;t used yet. Today&amp;#39;s problem got me
to explore Clojure Spec which is a very cool validation
library. There&amp;#39;s a complete run through of the solution in Clojure in
the video but here I&amp;#39;ll talk about the problem in Python (mostly). 
&lt;/p&gt;
&lt;p&gt;
Today&amp;#39;s &lt;a href=&#34;https://adventofcode.com/2020/day/4&#34;&gt;problem&lt;/a&gt; is about validating passports. You start with a text
file consisting of passport information. Each passport is one or more
lines with each line having a bunch of key value pairs. For example,
these two lines represent a passport for someone who&amp;#39;s eye color (ecl)
is gray (gry) and who was born (byr) in 1937:
&lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
ecl:gry pid:860033327 eyr:2020 hcl:#fffffd
byr:1937 iyr:2017 cid:147 hgt:183cm
&lt;/pre&gt;
&lt;p&gt;
The catch is that one passport can span multiple lines and that
passports are separated by two consecutive newlines in the file.
&lt;/p&gt;
&lt;p&gt;
A passport has 8 field types with one, Country of Origin (cid) being
optional.
&lt;/p&gt;
&lt;p&gt;
For part 1, a valid passport is one that contains all 7 required
fields. 
&lt;/p&gt;
&lt;p&gt;
The video goes over a Clojure solution which, I think is cleaner but
the idea is the same as the Python I&amp;#39;ll talk about here.
&lt;/p&gt;
&lt;p&gt;
Splitting the data into a list of potential passports is easy because
you can split the string on two newlines: 
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;../data/sample04.dat&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;read()
data&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;data&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
Now we have a list of string. 
&lt;/p&gt;
&lt;p&gt;
Next, we can split each string on whitespace so that each string in
each sublist is a string in the form &lt;strong&gt;k:v&lt;/strong&gt;: 
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;data_list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; d &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data:
    data_list&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append([item &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; d&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split()])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
So, for example, data_list[0] might look like this: 
&lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
[&amp;#39;ecl:gry&amp;#39;, &amp;#39;pid:860033327&amp;#39;, &amp;#39;eyr:2020&amp;#39;, &amp;#39;hcl:#fffffd&amp;#39;, &amp;#39;byr:1937&amp;#39;, &amp;#39;iyr:2017&amp;#39;, &amp;#39;cid:147&amp;#39;, &amp;#39;hgt:183cm&amp;#39;]
&lt;/pre&gt;
&lt;p&gt;
Finally, we can convert each passport into a dictionary: 
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;data_dicts&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[]
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; d &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data_list:
    temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { item&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]:item&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt;)[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; item &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; d} 
    temp&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pop(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;cid&amp;#39;&lt;/span&gt;,None)
    data_dicts&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(temp)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
The easiest way I came up with to check if a passport was valid was to
make a set out of a list of required field names, make a set out of
each potential passports field names (they&amp;#39;re dictionary keys) and see
if they&amp;#39;re equal: 
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;fields &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set([&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;byr&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;iyr&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;eyr&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hgt&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hcl&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ecl&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;pid&amp;#34;&lt;/span&gt;])
valid_passports &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;  [set(x&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;keys()) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; fields &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data_dicts]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
I think the Clojure code is cleaner but it&amp;#39;s much the same.
&lt;/p&gt;
&lt;p&gt;
Part two added a twist - you now have to not only see if the required
fields are there but you had to make sure they had valid data. For
example, height had to start with a positive integer followed by
either &lt;strong&gt;cm&lt;/strong&gt; or &lt;strong&gt;in&lt;/strong&gt;. If it was &lt;strong&gt;cm&lt;/strong&gt;, the number had to be in a certain
range and if it was &lt;strong&gt;in&lt;/strong&gt; it had to be within a different range. 
&lt;/p&gt;
&lt;p&gt;
This didn&amp;#39;t sound hard but could get tricky. For each field type you
could write a function that took in the value and returned true or
false depending on its validity - lots of ad hoc code. You could then
loop over all the passports and test to see if all the conditions were
met. 
&lt;/p&gt;
&lt;p&gt;
It turns out that Clojure has a really cool library - Clojure Spec
that does just that. You set up validators for each field type and
then one for an entire passport. Here&amp;#39;s the code: 
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-clojure&#34; data-lang=&#34;clojure&#34;&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/def&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::byr&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s/and&lt;/span&gt; string? &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(&amp;gt;= (&lt;span style=&#34;color:#a6e22e&#34;&gt;u/parse-int&lt;/span&gt; %) &lt;span style=&#34;color:#ae81ff&#34;&gt;1920&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(&amp;lt;= (&lt;span style=&#34;color:#a6e22e&#34;&gt;u/parse-int&lt;/span&gt; %) &lt;span style=&#34;color:#ae81ff&#34;&gt;2002&lt;/span&gt;)))
(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/def&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::iyr&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s/and&lt;/span&gt; string? &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(&amp;gt;= (&lt;span style=&#34;color:#a6e22e&#34;&gt;u/parse-int&lt;/span&gt; %) &lt;span style=&#34;color:#ae81ff&#34;&gt;2010&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(&amp;lt;= (&lt;span style=&#34;color:#a6e22e&#34;&gt;u/parse-int&lt;/span&gt; %) &lt;span style=&#34;color:#ae81ff&#34;&gt;2020&lt;/span&gt;)))
(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/def&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::eyr&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s/and&lt;/span&gt; string? &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(&amp;gt;= (&lt;span style=&#34;color:#a6e22e&#34;&gt;u/parse-int&lt;/span&gt; %) &lt;span style=&#34;color:#ae81ff&#34;&gt;2020&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(&amp;lt;= (&lt;span style=&#34;color:#a6e22e&#34;&gt;u/parse-int&lt;/span&gt; %) &lt;span style=&#34;color:#ae81ff&#34;&gt;2030&lt;/span&gt;)))
(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/def&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::hgt&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s/and&lt;/span&gt; string? hgt-test))
(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/def&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::hcl&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s/and&lt;/span&gt; string? &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(re-find &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;#[0-9a-f]{6}&amp;#34;&lt;/span&gt; %)))
(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/def&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::ecl&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s/and&lt;/span&gt; string? &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(re-find &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;amb|blu|brn|gry|grn|hzl|oth&amp;#34;&lt;/span&gt; %)))
(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/def&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::pid&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s/and&lt;/span&gt; string? &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;(re-find &lt;span style=&#34;color:#f92672&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;^[0-9]{9}$&amp;#34;&lt;/span&gt; % )))
(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/def&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::cid&lt;/span&gt; string?)
(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/def&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::passport&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s/keys&lt;/span&gt;
                   &lt;span style=&#34;color:#e6db74&#34;&gt;:req&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;::byr&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::iyr&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::eyr&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::hgt&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::hcl&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::ecl&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::pid&lt;/span&gt;]
                   &lt;span style=&#34;color:#e6db74&#34;&gt;:opt&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;::cid&lt;/span&gt;]))

(&lt;span style=&#34;color:#a6e22e&#34;&gt;s/valid?&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;::passport&lt;/span&gt; test-passport)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
The last line would test to see if &lt;strong&gt;test-passport&lt;/strong&gt; was valid. It&amp;#39;s all
covered in detail in the video.
&lt;/p&gt;
&lt;p&gt;
Clojure spec wasn&amp;#39;t required for this problem but I&amp;#39;ve been meaning to
play with it for a while and it led to a clean and elegant way of
testing passports. 
&lt;/p&gt;
&lt;p&gt;
Not sure if I&amp;#39;ll get to more posts or even solve more problems - I&amp;#39;m
trying to limit my own screen time over the weekends but we&amp;#39;ll see.
&lt;/p&gt;
&lt;p&gt;
If you want to check out all the Clojure goodness here it is: Enjoy!
&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/QzdCrJgXsww&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>A Teacher Looks at Advent of Code 2020 - Day 3</title>
      <link>https://cestlaz.github.io/post/advent-2020-day03/</link>
      <pubDate>Thu, 03 Dec 2020 14:27:02 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-day03/</guid>
      <description>&lt;p&gt;
I thought I&amp;#39;d do a video for today. No particular reason. Mostly why
not.
&lt;/p&gt;
&lt;p&gt;
I&amp;#39;ll talk about day 3&amp;#39;s problem and code up a solution in Clojure. If
you haven&amp;#39;t ever used Clojure, hopefully this will give a bit of the
flavor. This video also serves double duty as being my next Using
Emacs video since it demos Emacs&amp;#39;s Clojure tools. Mostly Cider which
even with a few quirks is the best development environment I&amp;#39;ve ever
used. 
&lt;/p&gt;
&lt;p&gt;
I don&amp;#39;t know if I&amp;#39;ll do any more videos or blog posts on AOC this
year. I hope to but I&amp;#39;m going to have to get to end of semester
obligations soon so you never know.
&lt;/p&gt;
&lt;p&gt;
Enjoy!
&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/ecJ1TJGWrfs&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>A Teacher Looks at Advent of Code 2020 - Day 2</title>
      <link>https://cestlaz.github.io/post/advent-2020-day02/</link>
      <pubDate>Wed, 02 Dec 2020 12:27:27 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-day02/</guid>
      <description>&lt;p&gt;
Day two introduced some staples of staples of not only Advent of Code but
also of programming problems in general. The first is input
parsing. For this problem you get lines of input like this:
&lt;/p&gt;
&lt;pre class=&#34;example&#34;&gt;
1-3 a: abcde
1-3 b: cdefg
2-9 c: cccccccc
&lt;/pre&gt;
&lt;p&gt;
or in general
&lt;/p&gt;
&lt;p&gt;
&lt;strong&gt;number_1&lt;/strong&gt;-&lt;strong&gt;number_2&lt;/strong&gt; &lt;strong&gt;Letter&lt;/strong&gt;: &lt;strong&gt;String&lt;/strong&gt; 
&lt;/p&gt;
&lt;p&gt;
There are a few ways to handle this. One is to brute force it. In
Python maybe something like: 
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;sample_line&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;4-15 f: abcdefg&amp;#34;&lt;/span&gt;
sample_list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sample_line&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split()
numbers&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sample_list[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
letter&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sample_list[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
string&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sample_list[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]

number_list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; numbers&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;)
num1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(number_list[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;])
num2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(number_list[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])

letter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; letter[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]

&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(num1, num2, letter, string)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
or more concisely: 
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;sample_line&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;4-15 f: abcdefg&amp;#34;&lt;/span&gt;

(numbers,letter,string) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sample_line&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split()

(num1,num2) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [int(x) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; numbers&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;)]

letter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; letter[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]

&lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(num1, num2, letter, string)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
If you&amp;#39;re working in a language like C, tools like &lt;code&gt;scanf&lt;/code&gt; can make
things easier. I generally turn to &lt;a href=&#34;https://blog.usejournal.com/regular-expressions-a-complete-beginners-tutorial-c7327b9fd8eb&#34;&gt;Regular Expressions&lt;/a&gt; and if you&amp;#39;re
doing some AOC with your classes this is a great time to introduce
regex. Basically, you set up a pattern with special symbols to
represent things like sequences of digits and then the regex matcher
does the hard work.
&lt;/p&gt;
&lt;p&gt;
Here&amp;#39;s the code to 
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;6
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;7
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;parser_expression&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;(\d+)-(\d+) ([a-z]): ([a-z]*)&amp;#34;&lt;/span&gt;
data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; line &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;../data/day02.dat&amp;#34;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;readlines():
    x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; re&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;search(parser_expression,line)
    (mini,maxi,letter,password) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;groups()
    mini &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(mini)
    maxi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(maxi)
    data&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append([mini,maxi,letter,password])&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
The &lt;code&gt;parser_expression&lt;/code&gt; in line 1 is the regular expression. Each
section in parentheses is a &amp;#34;group&amp;#34; or a pattern that will be
extracted. The &lt;strong&gt;\d&lt;/strong&gt; for instance means a digit and the &lt;strong&gt;+&lt;/strong&gt; adger it
means 1 or more digits so basically that will match any positive
integer. The &lt;strong&gt;[a-z]&lt;/strong&gt; matches a single character and the *after the
final character match means zero or more of them. Once you know
regular expressions, parsing lines like this becomes very easy. The
only thing that made the above code messy at all was that I wanted to
convert the two numbers into integers rather than leave them as
strings. 
&lt;/p&gt;
&lt;p&gt;
There are a couple of things worth thinking about here. First is know
your libraries. If you know regex the parsing is basically all
done. If not, you have a bit of work. On the other hand, you&amp;#39;re
probably not going to ever have to parse input exactly like this again
so it doesn&amp;#39;t make sense writing a super robust set of  parsing
functions tied in with this data specification. That&amp;#39;s the second
thing. Learning what to leave as building blocks and what to write
into libraries of your own. It&amp;#39;s most definitely worth writing a set
of routines that can be reused. Maybe something to parse dates in a
standard format would be an example. On the other hand, it&amp;#39;s also
worth knowing when you probably won&amp;#39;t be able to reuse things or when
generalizing to a library or set of functions you have to spend too
much time on a hundred options to make in general purpose.
&lt;/p&gt;
&lt;p&gt;
Now, part 1 of the problem itself is nice because there are a lot of
ways to do it. You could loop through the password and count the
number of times a letter occurs: 
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
subpassword &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; password[mini&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,maxi]
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; letter &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; subpassword:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; letter &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; what_im_looking_for:
        count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
or with a list comprehension &lt;code&gt;count = [x for x in password if x ==
waht_im_looking_for ]&lt;/code&gt;.
&lt;/p&gt;
&lt;p&gt;
You could be more general and build a hash table of counts and then
pull what you want: 
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;frequencies&lt;/span&gt;(word):
    d&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;{}
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; letter &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; word:
        d&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;setdefault(letter,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
        d[letter]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;d[letter]&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; d&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
This is admittedly overkill for the problem but one might need this
for part 2. I coded my original solution in Clojure and Clojure has a
function that does this in one shot: &lt;code&gt;frequencies&lt;/code&gt; so I just used that
and pulled the letter I needed.
&lt;/p&gt;
&lt;p&gt;
Once you have the count, it&amp;#39;s simple enough to see if it&amp;#39;s in the
range.
&lt;/p&gt;
&lt;p&gt;
Part 2 should have been easy but for me it was a lesson in
reading. You had to pull characters from the password at two specific
indices and see if one or the other, but not both were the letter in
question. Basically an xor. The first mistake one could make has to do
with the indexing and the second in using a regular or which students
will be more familiar with. 
&lt;/p&gt;
&lt;p&gt;
My mistake is that I misread the question as requiring that you have
one instance of the letter within the &lt;strong&gt;range&lt;/strong&gt; from the low index to
the high index not one instance at either of those two points Needless
to say, lots of wasted time and feeling silly. 
&lt;/p&gt;
&lt;p&gt;
So that&amp;#39;s day 2. The question is very approachable for APCS-A  and I&amp;#39;d
say even CS0 students. The interesting part to teach would be dealing
with the input, regular expressions, and how much to generalize into
utility functions when writing code over time.
&lt;/p&gt;
&lt;p&gt;
Hope to have time to solve and write up more of these but getting to
crunch time in the semester.
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Teacher Looks at Advent of Code 2020 - Day 1</title>
      <link>https://cestlaz.github.io/post/advent-2020-day-01/</link>
      <pubDate>Tue, 01 Dec 2020 09:03:39 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-day-01/</guid>
      <description>&lt;p&gt;
So, yesterday I was chatting with my daughter. She was talking with
her team and for some reason one of them pulled out an interview
question from their company&amp;#39;s question bank. Turns out it was today&amp;#39;s
Advent of Code problem. 
&lt;/p&gt;
&lt;p&gt;
As with past years, I&amp;#39;m going to try to solve the problems in Clojure
but if I can will talk Python when I talk about solutions. 
&lt;/p&gt;
&lt;p&gt;
Part 1 of the problem basically asks for you to find a pair of numbers
in an array that sum to a specific value. In this case 2020. Figuring
that this was day 1 I didn&amp;#39;t expect a crazy large data set or any
other tricks or weirdness - a straightforward solution should
suffice. Simply a loop within a loop and sum up all the pairs: 
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data:
  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2020&lt;/span&gt;:
      &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(x&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;y)&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
Nothing fancy but it gets the job done. It does print out the answer
twice since x and y both go through all the indices but that&amp;#39;s no big
deal.
&lt;/p&gt;
&lt;p&gt;
The part 2 twist was that now you were looking for a set of three
entries that added up to 220. Once again, not a big deal: 
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;4
&lt;/span&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; z &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;z &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2020&lt;/span&gt;:
                &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(x&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;y&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;z)&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
As before, you&amp;#39;ll get multiple answers but no big deal.
&lt;/p&gt;
&lt;p&gt;
What I like about this one is that you can think about this as a
looping exercise as above but you can also think about it as a list
processing exercise, that is, by thinking about it with more of a
functional programming bent. 
&lt;/p&gt;
&lt;p&gt;
The key insight here is that the question was clear in that there will
only be one pair in part 1 that satisfies the problem and likewise
only one pair in part 2. 
&lt;/p&gt;
&lt;p&gt;
If we look at each item in our data set, it&amp;#39;s part of the answer if
and only if there&amp;#39;s another number in the set equal to 2020 minus that
item. This leads to a list comprehension
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;part1_list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [x &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2020&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data]&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
Now, part1_list should contain the two items we need. The first value &lt;code&gt;x&lt;/code&gt;
was found when the comprehension saw that &lt;code&gt;2020 - x&lt;/code&gt; was in the list
and &lt;code&gt;2020-x&lt;/code&gt; which is the second value was confirmed when the for part
of the comprehension gets to it and finds that the first item is in
the list. Then, it&amp;#39;s a simple matter of just multiplying the two
numbers together for the answer.
&lt;/p&gt;
&lt;p&gt;
Part 2 is similar but you can use a list comprehension to iterate over
all pairs of elements and then you calculate the third:
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;part2_list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [x &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2020&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;(x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y) &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data]&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
Of course you could have put &lt;code&gt;y&lt;/code&gt; or &lt;code&gt;2020-(x+y)&lt;/code&gt; in place of that
first &lt;code&gt;x&lt;/code&gt;. 
&lt;/p&gt;
&lt;p&gt;
Part 2 has an additional subtlety in that you&amp;#39;ll get the solution
multiple times which makes sense you&amp;#39;re hitting each triple multiple
times. To fix that, turn it into a set: 
&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;
&lt;table style=&#34;border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;&#34;&gt;&lt;tr&gt;&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code&gt;&lt;span style=&#34;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td style=&#34;vertical-align:top;padding:0;margin:0;border:0;;width:100%&#34;&gt;
&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;part2_set &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set(part2_list)&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;
and then calculate the product.
&lt;/p&gt;
&lt;p&gt;
At the core, both of these solutions are really the same but you get
to them by thinking very differently. The first one is all about the
loops - thinking about data[i] at a very low discrete level. The
second approach is thinking about the data as a list and processing
that list at a much higher level. This could be an ice problem to
transition between the two approaches.
&lt;/p&gt;
&lt;p&gt;
Looking forward to what tomorrow&amp;#39;s problem brings.
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent of Code 2020</title>
      <link>https://cestlaz.github.io/post/advent-2020-leadin/</link>
      <pubDate>Mon, 30 Nov 2020 14:21:17 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/advent-2020-leadin/</guid>
      <description>&lt;p&gt;
Tomorrow, or more practically, tonight at Midnight,  &lt;a href=&#34;https://twitter.com/ericwastl&#34;&gt;Eric Wastl&lt;/a&gt; will
once again launch the &lt;a href=&#34;https://adventofcode.com&#34;&gt;Advent of Code&lt;/a&gt;. As I&amp;#39;ve written before, it&amp;#39;s a
month long event where each day a new programming problem is
released. The problems range in difficulty and complexity. Some are
very approachable to beginners and some are crazy challenging. I&amp;#39;ve
written a bunch about AOC in past years:
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://cestlaz.github.io/post/solve-a-to-solve-b/&#34;&gt;Solve A to Solve B&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://cestlaz.github.io/post/aoc-data-structures-hidden-complexity/&#34;&gt;Data structures and Hidden Complexity&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://cestlaz.github.io/posts/advent-2017-4-6/&#34;&gt;Tools can shape- how we think&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day1/&#34;&gt;2019 day 1&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day2/&#34;&gt;2019 day 2&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day3/&#34;&gt;2019 day 3&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day4/&#34;&gt;2019 day 4&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day8/&#34;&gt;2019 day 8&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://cestlaz.github.io/post/advent-2019-day8-part2/&#34;&gt;2019 day 8 addendum&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
and a few more not listed.
&lt;/p&gt;
&lt;p&gt;
If you haven&amp;#39;t heard of AOC, at the stroke of midnight (Eastern), a
new problem is released. From there you can read the problem, get the
input and figure out a solution, usually by writing a program. You
then type in your answer and if it&amp;#39;s correct you get part 2 - usually
a creative spin on part one. Usually you&amp;#39;ll write a program to solve
the problems but sometimes you&amp;#39;ll write code just to explore and come
up with an answer. 
&lt;/p&gt;
&lt;p&gt;
Even though there&amp;#39;s a leader board and people can set up their own
private leader boards, I describe AOC as an event not as a
competition. I&amp;#39;ve had former students up near the top but a getting
there requires a lot more than just problem solving. First, you have
to be up when the problem is released, then you have to shortcut scan
what the question is asking. Having a library of pre-written utility
routines is a big help as is using a language that has a lot of
interactive scripty functionality like Python. It also assumes that
even if you do all that is needed, that life doesn&amp;#39;t get in the
way. This means that to get to the top of the leader board, like in
most competitions you have to train and prepare to do just that and
training for that doesn&amp;#39;t really translate to the rest of life&amp;#39;s
challenges.
&lt;/p&gt;
&lt;p&gt;
Solving the problems, though, can translate to other challenges you
might face so I look at AOC as an opportunity to explore some
interesting problems. 
&lt;/p&gt;
&lt;p&gt;
I&amp;#39;ve never finished all of them and that&amp;#39;s okay. Here&amp;#39;s my star count
for each of the years. You get one star for each part of each question
so that&amp;#39;s 50 total.
&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Year:&lt;/strong&gt;&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;2015&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;2016&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;2017&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;2018&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;2019&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Stars:&lt;/strong&gt;&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;26&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;40&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;11&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;23&lt;/td&gt;
&lt;td class=&#34;align-right&#34;&gt;31&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
I&amp;#39;ve never gotten more than 40. I typically wake up and read the
question and see if I can solve it either then or over the course of
the day. Sometimes I&amp;#39;ll come back to a problem but usually not. Last
year, many problems were based on earlier ones. I had an issue in one
of those earlier solutions so never completed the later ones. 
&lt;/p&gt;
&lt;p&gt;
Maybe I&amp;#39;ll go back and finish more, maybe I won&amp;#39;t.
&lt;/p&gt;
&lt;p&gt;
None of this matters. 
&lt;/p&gt;
&lt;p&gt;
I had fun, learned a lot and as an added bonus, each problem gives me
an opportunity to reflect on how I might teach it or teach concepts
related to it.
&lt;/p&gt;
&lt;p&gt;
It all starts in a few hours so if you&amp;#39;re already planning on
participating, have a blast. If you haven&amp;#39;t, check it out.
&lt;/p&gt;
&lt;p&gt;
Advent of code can be found here: &lt;a href=&#34;https://adventofcode.com&#34;&gt;https://adventofcode.com&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
And, the AOC subreddit, which is great for problem discussions can be
found here: &lt;a href=&#34;https://www.reddit.com/r/adventofcode/&#34;&gt;https://www.reddit.com/r/adventofcode/&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
Enjoy. 
&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>